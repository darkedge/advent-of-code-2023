package main

import "core:fmt"
import "core:strings"
import "core:strconv"
import "core:sort"
import "core:unicode/utf8"

input := `....1.y.D...Y..........w....m.....................
..R..D..5....Y...1.........w.........G............
........R........D..o.............................
.............H......Y...w.....m...................
.......R..................3.........v.............
..1...D..5.........o................0.Bm..........
......5y.....o.........................3..........
....H...y......Z...............................0..
..............H.x..............m........w..g......
..........................A.......................
.........................................fg.......
...8.............v.....e............3B.....2......
.............5.....r......B.......2...........G..0
......................v....................3g.....
......P..............Y...c...........M.2.G........
..................................................
.....H....Z.............................K.......0.
....8d..Z......................u....X......f.g....
......d..P..r..............B.........E.........9..
.......r...........E..............q...M...........
...k...............v......Eb........q...........f.
.....R................b..............U.q9...2.....
.J......i.............M....q...................K..
..........d........................M.....A........
.......Zj..........h................9S............
.........j..........P..........Q....7.....c.......
.j........................a.......................
....j.6.....h.....F..a......L......c.X............
.................I.......a..b.............A......V
x........................p..........EK............
.......6.....................................X....
..J....................bf.....r.....K.............
.e..k................................7......X.....
...x..kP..................u...........U...........
J.8.....h....d........U....Q........F.c....iC.O...
...J...h.I..e......................i...7..........
..............................L.QU.....A......7...
...............k....t.........a.WO..i.............
.....4..6..............l...............T..........
........z...4.....p..........LS...Q...............
....e..z................t........pS..........C....
..............I........W.............9..........C.
..................l..........F...u...O............
....l............T.t.6...F.........S..s........V..
.......................t4.........................
.........z...........................CV....s......
..z.........IL.......W....p.........V...u.........
.....................l............................
........T.......................s.................
..........T..........4............................
`

main :: proc() {
  rows := strings.count(input, "\n")
  cols := strings.index(input, "\n")

  // [row, col]
  antennas := make(map[rune][dynamic][2]int)
  defer delete(antennas)

  // Populate antenna map
  lines := strings.split(input, "\n")
  for line, r in lines {
    if line == "" do continue
    for key, col in line {
      if key != '.' {
        if !(key in antennas) {
          // Note: These are not deleted
          antennas[key] = make([dynamic][2]int)
        }
        append(&antennas[key], [2]int{r, col})
      }
    }
  }

  antinodes := make(map[[2]int]bool)
  defer delete(antinodes)

  antinodes_resonant := make(map[[2]int]bool)
  defer delete(antinodes_resonant)

  // Plot antinodes
  // fmt.println(len(antennas))
  for key, arr in antennas {
    // fmt.println(key, arr)
    for left, i in arr {
      for right, j in arr[i + 1:] {
        // fmt.println(left, right)
        // Draw arrow from left to right
        d := right - left
        // Extend (add to right) and retract (subtract from left)
        points := [2][2]int{right + d, left - d}
        for p in points {
          if p[0] >= 0 && p[0] < rows && p[1] >= 0 && p[1] < cols {
            antinodes[p] = true
          }
        }

        for d_acc := left; d_acc[0] >= 0 && d_acc[0] < rows && d_acc[1] >= 0 && d_acc[1] < cols; d_acc -= d {
          antinodes_resonant[d_acc] = true
        }
        for d_acc := right; d_acc[0] >= 0 && d_acc[0] < rows && d_acc[1] >= 0 && d_acc[1] < cols; d_acc += d {
          antinodes_resonant[d_acc] = true
        }
      }
    }
  }
  
  fmt.println("unique antinode locations:", len(antinodes))

  fmt.println("including resonant harmonics:", len(antinodes_resonant))
}
